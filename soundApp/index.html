<html>

<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>

<body>
    <audio id='myAudio' src='lets begin.m4a'></audio>
    <button id='soundButton' onclick="playAudio()" type="button">Play Sounds</button>
    <button id='stopSoundButton' onclick="stopAudio()" type="button">Stop sounds</button>
    <p id='text'></p>
</body>
<script>
    const text = document.getElementById('text');
    const myAudio = document.getElementById('myAudio');
    const myAudioSounds = [
        'Birds.m4a',
        'Birds 2.m4a',
        'Birds one cough and fly.m4a',
        'Birds talk at end.m4a',
        'Birds with airplane.m4a',
        'birds with kitchen sounds.m4a',
        'Birds with neighbours talking.m4a',
        'Birds with weird pigeon noise.m4a'
    ];
    async function playAudio() {
        myAudio.play();
        const source = myAudio.getAttribute('src');
        text.innerHTML = 'Playing: ' + source;
    }

    function stopAudio() {
        myAudio.pause();
        myAudio.currentTime = 0;
        text.innerHTML = 'Audio Ended';
    }

    let audioEnded = false;
    myAudio.onended = function () {
        audioEnded = true; // just so the fade only works after at least one audio ended
        console.log('audio ended');
        const randomSound = myAudioSounds[Math.floor((Math.random() * myAudioSounds.length))];
        myAudio.setAttribute('src', randomSound);
        myAudio.play();
        console.log('Playing: ', randomSound);
        text.innerHTML = 'Playing: ' + randomSound;
    }

    myAudio.onloadeddata = async function () {
        console.log('data loaded');
        console.log('Not first audio', audioEnded);
        if (audioEnded === true) {
            const fadeDuration = 2000;
            fadeBetweenSounds(myAudio, fadeDuration);
        }
    }

    async function fadeBetweenSounds(element, fadeDuration) {
        const waitTillFade = element.duration * 1000 - fadeDuration;
        await sleep(waitTillFade);
        const numberOfIterations = 20;
        console.log('element volume', element.volume);
        await decreaseVolume(element, numberOfIterations, fadeDuration);
        await increaseVolume(element, numberOfIterations, fadeDuration);

    }

    async function decreaseVolume(element, numberOfIterations, fadeDuration) {
        if (element.volume != 1) {
            console.warn('Volume is not equal to 1');
            element.volume = 1;
        }
        console.log('Decreasing volume');
        const fixedNumOfIterations = numberOfIterations;
        const incrementalValue = 1 / fixedNumOfIterations;
        const numOfIterationsDec = element.volume / incrementalValue;
        let sleepTime = fadeDuration / fixedNumOfIterations;
        for (let i = numOfIterationsDec; i > 0; i--) {
            await sleep(sleepTime);
            //element.volume = parseFloat(element.volume - incrementalValue).toPrecision(2);
            element.volume = modifyVolume('squareRoot', i, numOfIterationsDec);
            console.log('volume', element.volume);
        }
    }

    async function increaseVolume(element, numberOfIterations, fadeDuration) {
        if (element.volume != 0) {
            console.warn('Volume is not equal to 0, instead: ', element.volume);
            element.volume = 0;
        }
        console.log('Increasing volume');
        const fixedNumOfIterations = numberOfIterations;
        const incrementalValue = 1 / fixedNumOfIterations;
        const numOfIterationsInc = fixedNumOfIterations - (element.volume / incrementalValue);
        console.log('num of iterations should be 20:', numOfIterationsInc);
        let sleepTime = fadeDuration / fixedNumOfIterations;
        for (let i = 0; i < numOfIterationsInc; i++) {
            await sleep(sleepTime);
            // element.volume = parseFloat(element.volume + incrementalValue).toPrecision(2);
            element.volume = modifyVolume('squareRoot', i, numOfIterationsInc);
            console.log('volume', element.volume);
        }
        element.volume = 1;
    }

    function modifyVolume(modifier, currentIteration, totalIterations) {
        // calculate limits from 0 to 1, where totalIterations is a parameter
        if (modifier === 'linear') {
            const incrementalValue = 1 / totalIterations; // when linear
            return parseFloat(currentIteration * incrementalValue).toPrecision(2);
        } else if (modifier === 'sinusoidal') {
            const incrementalValue = 0.5 * Math.PI / totalIterations;
            return Math.sin(incrementalValue * currentIteration).toFixed(2);
        } else if (modifier === 'squareRoot') {
            const incrementalValue = 1 / totalIterations;
            return Math.sqrt(incrementalValue * currentIteration).toFixed(2);
        }
    }

    async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }




</script>

<html>